वर्चुअल मेमोरी एक प्रकार की कंप्यूटर प्रणाली तकनीक है जो एक कंप्यूटर प्रोग्राम को यह धारणा प्रदान करता है कि इसके पास एक सन्निहित कार्य क्षमता वाली मेमोरी है। जबकि वास्तव में इसे प्राकृतिक रूप से विभिन्न हिस्सों में विभाजित किया जा सकता है और डिस्क स्टोरेज में बहुत अधिक मात्रा में हो सकता है। जो प्रणालियां इस तकनीक का प्रयोग करती हैं वे बड़े ऐप्लीकेशन वाले प्रोग्रामिंग को अधिक सरल बनाती हैं और बिना वर्चुअल मेमोरी वाले ऐप्लीकेशन की अपेक्षा वास्तविक भौतिक स्मृति का अधिक कुशलतापूर्वक उपयोग करती है। वर्चुअल मेमोरी स्मृति के आभासीकरण से इस अर्थ में भिन्न है कि वर्चुअल मेमोरी संसाधनों को एक विशेष प्रणाली के लिए आभासीकृत करने देती है। इसके विपरीत मेमोरी का एक बड़ा पूल विभिन्न प्रणालियों के लिए छोटे पूलों में आभासीकृत होता है। 
ध्यान दें कि "वर्चुअल मेमोरी" "डिस्क स्थान का उपयोग भौतिक स्मृति का आकार बढाने" से अधिक कुछ करता है - अर्थात हार्ड डिस्क ड्राइव को शामिल करने के लिए सिर्फ मेमोरी पदानुक्रम का विस्तार. डिस्क के मेमोरी का विस्तार वर्चुअल मेमोरी तकनीक के उपयोग करने का एक स्वाभाविक परिणाम है, लेकिन इसे अन्य साधनों जैसे कि उपरिशायी या गमागमन प्रोग्रामों और उनके निष्क्रिय आंकड़ों को डिस्क से पूरी तरह से बाहर कर किया जा सकता है। "वर्चुअल मेमोरी" की परिभाषा प्रोग्राम को चिंतन में बदलने के लिए ऐड्रेस स्पेस के सन्निहित वर्चुअल मेमोरी ऐड्रेसों के रूप में पुनर्परिभाषित करने पर आधारित है कि वे सन्निहित ऐड्रेसों के बड़े ब्लॉकों का उपयोग कर रहे हैं।
आधुनिक सामान्य उद्देश्य वाले कंप्यूटर ऑपरेटिंग सिस्टम आम तौर पर वर्चुअल मेमोरी तकनीकों का प्रयोग सामान्य ऐप्लीकेशन्स जैसी कि वर्ड प्रोसेसर, स्प्रेडशीट, मल्टीमीडिया प्लेयर, लेखांकन, आदि के रूप में करते हैं सिवाय जहां आवश्यक हार्डवेयर सहायता अनुपलब्ध हो. पुराने ऑपरेटिंग सिस्टम जैसे कि 1980 के दशकों के DOS, 1960 के दशकों मेनफ्रेमों में आम तौर पर वर्चुअल मेमोरी संबंधी कोई व्यावहारिकता नहीं थी -इसके उल्लेखनीय अपवाद एटलस, B5000 और एप्पल कंप्यूटर लिसा थे।
सन्निहित प्रणालियां और अन्य विशेष उद्देश्य वाली कंप्यूटर प्रणालियां जिनके लिए बहुत तेज और/या बहुत अनुकूल प्रतिक्रिया समय की आवश्यकता होती है वे घटे हुए निर्धारण के कारण वर्चुअल मेमोरी का उपयोग नहीं करना चाह सकती हैं।

सन् 1940 और 1950 के दशक में, एक वर्चुअल मेमोरी के विकास से पहले, सभी बड़े प्रोग्रामों में द्वि-स्तरीय स्टोरेज के प्रबंधन के लिए तर्क शामिल होता था, जैसे कि उपरिशायी तकनीकें. अधिचित्रों को द्वितीयक स्टोरेज से प्राथमिक स्टोरेज में आगे पीछे करने के लिए प्रोग्राम जिम्मेदार था।
इसलिए वर्चुअल मेमोरी शुरू करने का मुख्य कारण न केवल प्राथमिक मेमोरी का विस्तार करना था, बल्कि ऐसे विस्तारण को प्रोग्रामरों के उपयोग हेतु यथासंभव सरल बनाना था।
कई प्रणालियों में पहले से ही मेमोरी को विविध प्रोग्रामों में विभाजित करने की क्षमता थी, जिसे वर्चुअल मेमोरी प्रदान किये बिना उदाहरण के लिए "बेस एंड बाउंड रजिस्टर" के द्वारा PDP-10 के आरंभिक मॉडलों के लिए प्रदान किया जाता था। उसने प्रत्येक ऐप्लीकेशन को एक एक निजी ऐड्रेसस्थान प्रदान किया जो 0 के एक पते पर प्रारंभ होता था। इसके साथ निजी ऐड्रेस स्थान में किसी ऐड्रेस की बाउंड रजिस्टर यह सुनिश्चित करने के लिए जांच की जाती थी कि यह ऐप्लीकेशन के लिए आबंटित मेमोरी खंड के भीतर है और, यदि ऐसा है, तो किसी ऐड्रेस को मुख्य मेमोरी में रखने के लिए संगत बेस रजिस्टर की अंतर्वस्तु इसमें जोड़ी गई है। यह बिना वर्चुअल मेमोरी वाली विभाजन का एक सरल रूप है।
वर्चुअल मेमोरी लगभग 1959-1962 में एटलस कंप्यूटर के मैनचेस्टर विश्वविद्यालय में विकसित किया गया और इसे 1962 में पूरा किया गया। हालांकि, जर्मनी के अग्रणी कंप्यूटर वैज्ञानिकों में से एक, फ्रिट्ज-रुडोल्फ गुन्त्स्च और बाद में टेलिफूंकेन TR 440 मेनफ्रेम के डेवलपर के बारे में यह दावा किया जाता है कि उन्होंने उनकी डॉक्टरेट शोध प्रबंध 'Logischer Entwurf{ eines Rechengerätes mit mehreren asynchron laufenden Trommeln und automatischem Schnellspeicherbetrieb{/1} की अवधारणा का आविष्कार किया . 
1961 में, बरोज़ ने वर्चुअल मेमोरी युक्त प्रथम व्यावसायिक कंप्यूटर B5000 का विमोचन किया। इसने पृष्ठन की बजाय विभाजन का प्रयोग किया।
कंप्यूटिंग के इतिहास में कई तकनीकों की तरह, वर्चुअल मेमोरी को बिना चुनौती के स्वीकार नहीं किया गया। मुख्यधारा के ऑपरेटिंग सिस्टम में लागू किये जा सकने के पहले, विभिन्न समस्याओं पर काबू पाने के लिए कई मॉडलों, प्रयोगों और सिद्धांतों का विकास किया जाना था। गतिक ऐड्रेस रूपांतरण के लिए एक विशेषीकृत, महंगी और निर्माण करने में कठिन हार्डवेयर की आवश्यकता थी। इसके अलावा शुरू में इसने मेमोरी के ऐक्सेस को थोड़ा धीमा कर दिया. इस बात की भी चिंताएं थी कि द्वितीयक स्टोरेज का उपयोग करने वाली नयी प्रणाली - व्यापक कलनविधि पहले उपयोग कि गयी ऐप्लीकेशन-विशेष विधि कि अपेक्षा बहुत कम प्रभावकारी होगी.
1969 तक व्यावसायिक कंप्यूटर के लिए वर्चुअल मेमोरी के संबंध में बहस समाप्त हो गयी थी। डेविड सायरे के नेतृत्व में IBM के एक शोध दल ने यह दिखाया कि वर्चुअल मेमोरी उपरिशायी प्रणाली ने सर्वश्रेष्ठ हस्त नियंत्रित प्रणालियों की तुलना में निरंतर बेहतर काम किया।
संभवतः वर्चुअल मेमोरी व्यवहार में लाने वाला पहला मिनी कंप्यूटर नार्वे का NORD-1 था। 1970 के दशक के दौरान, अन्य मिनी कम्प्यूटरों ने वर्चुअल मेमोरी, विशेष रूप से VMS पर चलने वाले VAX मॉडलों को लागू किया।
वर्चुअल मेमोरी को इंटेल 80286 प्रोसेसर के सुरक्षित मोड के साथ x86 संरचना के साथ व्यवहार में लाया गया। शुरू में इसे खंड गमागमन के साथ किया गया, जो अधिक बड़े खण्डों के साथ बेकार साबित हुआ। इंटेल 80386 ने मौजूदा विभाजन परत के नीचे पृष्ठन के लिए सहारे की शुरुआत की. बिना दोहरे दोष उत्पन्न किये पृष्ठ दोष अपवाद को अन्य अपवाद के साथ श्रृंखलित जा सकता है।

वर्चुअल मेमोरी के प्राय: सभी कार्यान्वयन किसी ऐप्लीकेशन प्रोग्राम के वर्चुअल ऐड्रेस स्पेस को पेजों में विभाजित करते हैं; पेज संलग्न वर्चुअल मेमोरी ऐड्रेसों का एक ब्लॉक होता है। पेजों के आकार आम तौर पर कम से कम 4K बाइट होते हैं और बड़े वर्चुअल मेमोरी ऐड्रेसों वाली प्रणालियां या वास्तविक मेमोरी के बहुत बड़े परिमाण आम तौर पर बड़े आकार के पेजों का उपयोग करते हैं। 

लगभग सभी कार्यान्वयन ऐप्लीकेशन प्रोग्राम के द्वारा देखे गये वर्चुअल ऐड्रेसों को भौतिक ऐड्रेसों में रूपान्तरित करने के लिए पृष्ठ सारणी का प्रयोग करते हैं जिनका उपयोग हार्डवेयर के द्वारा निर्देशों को संसाधित करने के लिए किया जाता है। पृष्ठ सारणी में प्रत्येक प्रविष्टि या तो वर्चुअल पेज के लिए वास्तविक मेमोरी ऐड्रेस, जहां पेज को संचित किया जाता है, या एक सूचक कि पेज को वर्तमान में एक डिस्क फ़ाइल में रखा गया है, में एक मानचित्रण शामिल होता हैं। 
प्रणालियों में पूरी प्रणाली के लिए एक पृष्ठ वाली सारणी या प्रत्येक ऐप्लीकेशन के लिए अलग-अलग पृष्ठ सारणी हो सकती है। यदि ऐसा केवल एक ही होता है, तो एक ही समय में चलने वाले विभिन्न ऐप्लीकेशन एक ही वर्चुअल ऐड्रेस स्पेस का साथ-साथ प्रयोग करती हैं, अर्थात वे एक ही अनुक्रम वाले वर्चुअल एड्रेसों के विभिन्न भागों का प्रयोग करते हैं। जो प्रणालियां एकाधिक पृष्ठ सारणियों का उपयोग करती हैं वे एकाधिक वर्चुअल ऐड्रेस स्पेस प्रदान करती हैं - समवर्ती ऐप्लीकेशन का सोचना है कि वे सामान अनुक्रम वाले वर्चुअल ऐड्रेसों का उपयोग कर रहे हैं, लेकिन उनके अलग- अलग पृष्ठ सारणी विभिन्न वास्तविक ऐड्रेसों की तरफ अनुप्रेषित क्लाराते हैं।

यदि, किसी निर्देश को निष्पादित करने के समय, एक CPU एक ख़ास वर्चुअल ऐड्रेस में स्थित एक निर्देश प्राप्त करता है, एक विशिष्ट वर्चुअल ऐड्रेस से आंकड़ा प्राप्त करता है या किसी ख़ास वर्चुअल ऐड्रेस में आंकड़ा संग्रह करता है, तो वर्चुअल ऐड्रेस को सांगत भौतिक ऐड्रेस में रूपांतरित किया जाना चाहिए. इसे एक हार्डवेयर अवयव के द्वारा किया जाता है, जिसे कभी-कभी एक मेमोरी प्रबंधन इकाई कहा जाता है। यह वर्चुअल ऐड्रेस के संगत वास्तविक ऐड्रेस की खोज करता है और और वास्तविक ऐड्रेस को CPU के भागों में भेज देता है जो निर्देशों पर अमल करते हैं। यदि पृष्ठ सारणी यह सूचित करता है कि वर्चुअल मेमोरी पेज वर्तमान में वास्तविक मेमोरी में नहीं है, तो हार्डवेयर एक पृष्ठ दोष अपवाद उत्पन्न करता है जो ऑपरेटिंग सिस्टम के पृष्ठन पर्यवेक्षक घटक शुरू करता है .

ऑपरेटिंग सिस्टम का यह भाग पृष्ठ सारणी को तैयार करता है और उसका प्रबंधन करता है। यदि गतिशील ऐड्रेस रूपांतरण हार्डवेयर एक पृष्ठ दोष अपवाद उत्पन्न करता है, तो आवश्यक वर्चुअल ऐड्रेस वाले पेज के द्वितीयक स्टोरेज में पेज स्पेस कि खोज करता है, इसे वास्तविक भौतिक स्मृति में पढ़ता है, वर्चुअल ऐड्रेस के नए स्थान को दर्शाने के लिए पृष्ठ सारणी का नवीनीकरण करता है और अंत में गतिक ऐड्रेस रूपांतरण को पुन: खोज शुरू करने के लिए कहता है। आमतौर पर सभी वास्तविक भौतिक मेमोरी पहले से ही उपयोग में रहते हैं और पृष्ठन पर्यवेक्षक को सबसे पहले वास्तविक भौतिक मेमोरी के एक हिस्से को डिस्क में अवश्य ही सेव करें और पृष्ठ सारणी का नवीनीकरण करें ताकि यह बताया जा सके कि संबंधित वर्चुअल ऐड्रेस अब वास्तविक भौतिक मेमोरी में नहीं है बल्कि डिस्क में सेव किये गए हैं। पृष्ठन पर्यवेक्षक आम तौर पर वास्तविक भौतिक मेमोरी वाले उन हिस्सों को सेव करते हैं और उनका अधिलेखन करते हैं जिनका हाल ही में उपयोग किया जा चुका है, क्योंकि संभवतः ये वैसे क्षेत्र हैं जिनका अक्सर कम से कम उपयोग किया जाता है। इसलिए हर बार गतिक ऐड्रेस रूपांतरण हार्डवेयर का एक वास्तविक भौतिक मेमोरी वाले ऐड्रेस के साथ सुमेलन होने पर, इसे उस वर्चुअल ऐड्रेस के लिए पृष्ठ तालिका प्रविष्टि में समय का एक मुहर लगाना चाहिए.

सभी वर्चुअल मेमोरी सिस्टमों में मेमोरी वाले क्षेत्र होते हैं जो "जकडे हुए" होते हैं, अर्थात् उन्हें द्वितीयक स्टोरेज में स्थानांतरित नहीं किया जा सकता है, उदाहरण के लिए:

MVS, z/OS और इसी तरह के OSes में, सिस्टम मेमोरी के कुछ हिस्सों का प्रबंधन वर्चुअल = वास्तविक विधि में किया जाता है, जहां प्रत्येक वर्चुअल एड्रेस एक वास्तविक एड्रेस के संगत होता है। वे हैं: 
आईबीएम के आरंभिक वर्चुअल मेमोरी सिस्टम वर्चुअल = वास्तविक मोड पेजों को जकड़ने का एक मात्र तरिका था। Z/OS में 3 मोड होते हैं, V = V, V=R और V=F .

कुछ प्रणालियां, जैसे की बर्रोज लार्ज सिस्टम, वर्चुअल मेमोरी के कार्यान्वयन के लिए पृष्ठन का प्रयोग नहीं करते हैं। इसके बजाय, वे विभाजन का उपयोग करते हैं, ताकि किसी ऐप्लीकेशन के वर्चुअल ऐड्रेस स्पेस को चर लंबाई के खंडों में विभाजित किया जा सके. एक वर्चुअल ऐड्रेस में एक खंड संख्या और खंड के भीतर एक ऑफसेट होता है।
मेमोरी को अब भी एक ही संख्या के द्वारा भौतिक रूप से व्यक्त किया जाता है। इसे प्राप्त करने के लिए, एक खंड विवरणक की खोज करने के लिए प्रोसेसर खंड सारणी में खंड संख्या की खोज करता है। खंड विवरणक में एक चिन्हक होता है जो यह सूचित करता है कि क्या खंड मुख्य मेमोरी में उपस्थित है और, यदि ऐसा है, तो खंड के शुरू में मुख्य मेमोरी में ऐड्रेस और खंड की लंबाई सूचित करता है। यह जांच करता है कि खंड के भीतर ऑफसेट कि लंबाई खंड कि लंबाई से कम है या नहीं और, यदि ऐसा नहीं है, तो क्या कोई अवरोध उत्पन्न होता है। यदि कोई खंड मुख्य मेमोरी में मौजूद नहीं रहता है, तो ऑपरेटिंग सिस्टम में हार्डवेयर संबंधी एक अवरोध उत्पन्न उत्पन्न किया जाता है, जो मुख्य मेमोरी में खंड को पढ़ने या कार्यान्वयन के दौरान पृष्ठांकित आंकड़ों के सेट को सहायक स्टोरेज से वास्तविक स्टोरेज में स्थानांतरित करने की कोशिश कर सकता है। खंड को पढ़े जाने के लिए मुख्य मेमोरी में जगह बनाने हेतु ऑपरेटिंग सिस्टम को मुख्य मेमोरी में से अन्य खण्डों को हटाना पद सकता है।
विशेष रूप से, इंटेल 80286 ने एक विकल्प के रूप में इसी प्रकार की एक विभाजन योजना का समर्थन किया, लेकिन अधिकांश ऑपरेटिंग सिस्टमों द्वारा इसका उपयोग नहीं किया गया।
विभाजन और पृष्ठन का सम्मिश्रण करना, आमतौर पर प्रत्येक खण्डों को पृष्ठों में विभाजित करना संभव है। जो सिस्टम उन्हें सम्मिश्रित करते हैं, जैसे कि Multics और IBM System/38 और IBM System i मशीन में, वर्चुअल मेमोरी को आमतौर पर पृष्ठन के साथ लागू किया जाता है, जिसमें विभाजन का प्रयोग मेमोरी को सुरक्षा प्रदान करने के लिए किया जाता है। इंटेल 80386 और बाद में IA-32 प्रोसेसरों के साथ, खंड एक 32-bit वाले रैखिक पृष्ठन वाले ऐडरेस स्पेस में स्थित रहते हैं। इसलिए खण्डों को उस रैखिक पृष्ठन वाले ऐडरेस स्पेस के भीतर और बाहर किया जा सकता है। इससे वर्चुअल मेमोरी के दो स्टार मिलते हैं; हालांकि बहुत कम ही ऑपरेटिंग सिस्टम ऐसा करते हैं। इसके बजाय, वे केवल पृष्ठन का उपयोग करते हैं।
पृष्ठों और खण्डों का उपयोग कर वर्चुअल मेमोरी के कार्यान्वयन में अंतर न केवल क्रमश: निश्चित और चर आकारों के द्वारा मेमोरी के विभाजन से संबंधित है। कुछ प्रणालियों में, जैसे कि मल्टिक्स, या बाद में सिस्टम/38 और प्राईम मशीन्स में, एक मेमोरी मॉडल के अर्थ विज्ञान के रूप में, विभाजन वास्तव में उपयोगकर्ता प्रक्रियाओं में दिखाई देता था। दूसरे शब्दों में, उस एक प्रक्रिया के बदले में जिसमें एक मेमोरी होता था जो बाइट्स या शब्दों के एक बड़े वेक्टर के जैसा दिखाई देता था। यह अधिक संरचित था। यह पृष्ठों के प्रयोग करने से भिन्न है, जो प्रक्रिया में दिखाई देने वाले मॉडल को नहीं बदलता है। इसके महत्वपूर्ण परिणाम हुए.
खंड न केवल "चर लंबाई वाला एक पृष्ठ", या ऐडरेस स्पेस की लंबाई को बढ़ाने का एक एक सीधा तरिका नहीं था . मल्टिक्स में, विभाजन एक बहुत शक्तिशाली तंत्र था जिसका उपयोग एक एक-स्तरीय वर्चुअल मेमोरी मॉडल प्रदान करने के लिए किया जाता था, जिसमें "प्रोसेस मेमोरी" और "फाइल सिस्टम" के बिच कोई अंतर नहीं था - एक 'प्रप्रोसेस एक्टिव ऐड्रेस स्पेस में केवल खण्डों कि एक सूचि होती थी जिन्हें इसके संभावित ऐड्रेस, कोड और डेटा, दोनों में प्रतिचित्रित किया जाता था।यह यूनिक्स में बाद के mmap क्रियाविधि के समान नहीं था, क्योंकि अर्द्ध - स्वेच्छ स्थानों में फाइलों को प्रतिचित्रित करने के समय अंतर फ़ाइल पॉइंटर संकेत काम नहीं करते हैं। मल्टिक्स में अधिकाँश निर्देशों में निर्मित ऐसे पताभिगमन मोड थे। दूसरे शब्दों में, यह पुनर्स्थापित अंतर खंड संदर्भ क्रियान्वित कर पूरी तरह से एक लिंकर की जरूरत को समाप्त कर सकता था। यह उस समय भी काम करता था जब विभिन्न प्रक्रियाएं एक ही फाइल को विभिन्न स्थानों में उनके निजी ऐड्रेस स्पेसों में प्रतिचित्रित करता था। 

सभी implementations के लिए एक समस्या बुलाया "ताड़ना", जहां कंप्यूटर भी ज्यादा समय बिताता है असली स्मृति और डिस्क के बीच आभासी स्मृति के ब्लॉक फेरबदल और इसलिए धीरे काम लगता है बचने की जरूरत है। अनुप्रयोग प्रोग्राम कर सकते हैं मदद के बेहतर डिजाइन, लेकिन अंत में ही इलाज के लिए और अधिक वास्तविक स्मृति स्थापित है। अधिक जानकारी के लिए पृष्ठन देखते हैं।



qwqwwwwwwww
