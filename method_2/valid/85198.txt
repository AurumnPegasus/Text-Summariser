जावा एक प्रोग्रामिंग भाषा है जिसे मूलतः सन माइक्रोसिस्टम्स के जेम्स गोसलिंग द्वारा विकसित किया गया तथा 1995 में इसे सन माइक्रोसिस्टम्स के जावा प्लेटफ़ार्म के एक मुख्य अवयव के रूप में रिलीज़ किया गया। भाषा अपना अधिकांश वाक्य विन्यास C और C++ से प्राप्त करती है लेकिन इसके पास एक सरल ऑब्जेक्ट मॉडल और कुछ निम्न स्तर की सुविधायें मौजूद हैं। जावा के प्रयोगों को विशिष्ट रूप से बाईटकोड के लिए संकलित किया जाता है जिसे किसी भी कंप्यूटर आर्किटेक्चर वाले किसी भी जावा वर्चुअल मशीन पर चालू किया जा सकता है।
1995 से सन द्वारा मूल तथा सन्दर्भ कार्यान्वयन जावा संकलकों, वर्चुअल मशीनों और क्लास लाइब्रेरियों को विकसित किया गया। मई 2007 तक, जावा कम्युनिटी प्रोसेस के विशेष उल्लेखपूर्वक अनुमति में सन ने अपने अधिकांश जावा प्रोद्योगिकियों को GNU जनरल पब्लिक लाइसेन्स के अर्न्तगत मुफ्त सॉफ्टवेयर के रूप में उपलब्ध कराया. दूसरों ने भी सन की इन प्रोद्योगिकियों के वैकल्पिक कार्यान्वयनों को विकसित किया, जैसे कि GNU क्लासपाथ और जावा के लिए GNU कम्पाइलर.
जून 1991 में जेम्स गोसलिंग ने अपने कई सेट-टॉप बॉक्स परियोजनाओं में से किसी एक परियोजना में उपयोग करने के लिए जावा भाषा परियोजना को प्रारम्भ किया। इस भाषा का नाम पहले ओक था जिसका नामकरण गोसलिंग के कार्यालय के बाहर स्थित एक ओक पेड़ के नाम पर हुआ था। इसके बाद इसका नाम ग्रीन भी पड़ा और अंत में इसका नाम जावा पड़ा. यह जावा नाम क्रमबद्ध शब्दों की एक सूची में से लिया गया। गोसलिंग का लक्ष्य था कि वे एक वर्चुअल मशीन व एक भाषा की शुरुआत करें जो C/C++ शैली पद्वति से परिचित हो। 
1995 में सन ने जावा 1.0 के रूप में पहला सार्वजनिक कार्यान्वयन रिलीज़ किया। प्रचलित प्लेटफार्मों पर बिना-मूल्य रन-टाइम की सुविधा प्रदान करते हुए इसने "राइट वंस, रन एनीव्हेयर" का वादा किया। पर्याप्त सुदृढ़ और समनुरूपयोग्य सुरक्षा प्रकट करते हुए इसने नेटवर्क और फाइल एक्सेस के प्रतिबंधों को अनुमति दे दी। मुख्य वेब ब्राउज़रों ने जल्द ही वेबपेजों के भीतर जावा एप्लेटों को चलाने की योग्यता को सम्मिलित कर लिया और जल्द ही जावा विख्यात हो गया। जावा 2 के आगमन के साथ नये भाषांतरों में बहु आकृति थी जो विभिन्न प्रकार के प्लेटफार्मों के लिए निर्मित थी। उदाहरणस्वरुप, एंटरप्राइज़ अप्लिकेशन के लिए लक्षित J2EE और मोबाइल अप्लिकेशन के लिए अत्यंत नवीन वर्सन J2ME . J2SE ने मानक संस्करण को लक्षित किया। 2006 में, व्यापर के उद्देश्य से सन ने J2 के नये वर्सनों का नाम बदलकर क्रमश: जावा EE, जावा ME और जावा SE कर दिया।
1997 में, सन माइक्रोसिस्टमस ने जावा को अमली जामा पहनाने के लिए ISO/IEC JTC1 मानक समिति को और बाद में ऐक्मा अंतराष्ट्रीय को प्रस्ताव भेजा, पर जल्द ही यह इस प्रक्रिया से हट गई। जावा समुदाय प्रक्रिया द्वारा नियंत्रित जावा वास्तव में एक डी फैक्टो मानक बना हुआ है। अपने सॉफ्टवेयर मालिक होने के दर्जे के बावजूद, एक बार सन ने बिना शुल्क के जावा कार्यान्वयन का अधिकांश हिस्सा उपलब्ध कराया. सन ने जावा से विशेष उत्पाद जैसे जावा इंटरप्राइज सिस्टम को लाइसेंस बेचकर मुनाफा कमाया. सन ने अपने सॉफ्टवेयर डेवेलपमेंट किट और रनटाइम एनवायरनमेंट ) में भेद किया; प्राथमिक भेद में JRE का कम्पाइलर की कमी, उपयोगिता प्रोग्राम और हेडर फाइल्स शामिल हैं।
13 नवम्बर 2006 को, सन ने GNU जनरल पब्लिक लाइसेन्स के शर्तों के अधीन अधिकांश जावा को स्वतंत्र और मुक्त स्रोत सॉफ्टवेयर के रूप में रिलीज़ किया। 8 मई 2007 को सन ने प्रक्रिया का समापन किया, कोड के एक छोटे से हिस्से जिस पर सन का प्रकाशनाधिकार नहीं है, उसे छोड़कर बाकि जावा के सभी कोर कोड को मुफ्त सॉफ्टवेयर/मुक्त-स्त्रोत वितरण शर्त के तहत उपलब्ध कराया.
जावा भाषा को निर्मित करने के पांच मुख्य उद्देश्य थे:
हालांकि जावा का अधिकांश प्रत्यक्ष मुनाफा लाइसेंसिंग और JCP सदस्यता राशि से आता है, कुछ मानते हैं कि जावा प्रमुखतः हार्डवेयर सर्वर को बढ़ावा देने का एक वाहन और/या आंतरिक रूप से सन के लिए सोलारिस OS की बिक्री हैं और सन के उपाध्यक्ष रिच ग्रीन ने कहा कि जावा के लिए सन की आदर्श भूमिका "इंजीलवाद" के जैसी है।
जावा की एक विशेषता वहनीयता है, जिसका मतलब है कि जावा भाषा में लिखे गए कंप्यूटर प्रोग्राम किसी भी हार्डवेयर समर्थित/ऑपरेटिंग सिस्टम प्लेटफॉर्म पर समान रूप से कार्य करता है। इसे जावा भाषा संकेत को संकलित करके प्राप्त किया गया है, मशीन कोड से नहीं बल्कि जावा बाईटकोड से, - निर्देश मशीन संकेत के अनुरूप है लेकिन विशेष तौर पर होस्ट हार्डवेयर के लिए लिखित वर्चुअल मशीन द्वारा भाषांतरित करना अभीष्ट होगा। एंड-यूज़र्स सामान्य तौर पर स्टैंडअलोन प्रयोग मशीन/या जावा एप्लेट्स के लिए वेब ब्राउजर में जावा रनटाइम एनवायरनमेंट का इस्तेमाल करते हैं, जो उनके स्वयं के मशीन पर संस्थापित है।
मानकताप्राप्त लाइब्रेरीज होस्ट विशिष्ट सुविधाओं जैसे:- आरेखी, थ्रेडिंग और नेटवर्किंग के अभिगमन के लिए एक क्रियाशील रास्ता प्रदान करते हैं।
बाईटकोड को इस्तेमाल करने का सबसे मुख्य लाभ है वहनता. जो कुछ भी हो, भाषांतरण के ऊपरी भाग का मतलब होता है कि भाषांतरित प्रोग्राम्स हमेशा मूल निष्पादनयोग्य से संकलित प्रोग्राम्स से ज्यादा धीरे चलती हैं और बुरे प्रदर्शन के कारण जावा की साख को नुकसान होता है। हाल ही में JVM कार्यान्वयन में कई ईष्टतमीकरण तकनीकों के आने से यह परेशानी थोड़ी कम हो गई है।
सन माइक्रोसिस्टम्स आधिकारिक तौर पर जावा मानक संस्करण प्लेटफॉर्म Linux, Mac OS X और Solaris के लिए लाइसेंस देती है. हालांकि, पूर्व में सन ने Microsoft को जावा लाइसेंस दिया, लाइसेंस की अवधि समाप्त हो चुकी है और इसका फिर से नवीकरण नहीं किया गया है। तीसरे-समूह के विक्रेताओं और लाइसेंसधारियों के नेटवर्क द्वारा, वैकल्पिक जावा एनवायरनमेंट इसके और दूसरे प्लेटफॉर्मस के लिए उपलब्ध हैं।
जावा ब्रांड का उपयोग करने के लिए सन का ट्रेडमार्क लाइसेंस दृढ़तापूर्वक कहता है कि सभी क्रियान्वयन 'उपयुक्त' हो। इसका परिणाम Microsoft के साथ कानूनी विवाद के रूप में निकला जब सन ने दावा किया कि Microsoft क्रियान्वयन RMI और JNI को समर्थन नहीं करती और इसमें उसके स्वयं के अतिरिक्त प्लेटफॉर्म-विशिष्ट विशेषताएं हैं। सन ने 1997 में अभियोग चलाया और 2001 में 20 मिलियन डॉलर का भुगतान और साथ ही साथ सन के लाइसेंस की शर्तो को लागू करने का कोर्ट का आदेश भी पाया। परिणामस्वरूप, Microsoft ने विंडोज के साथ जावा को ज्यादा दिन नहीं चलाया और विंडोज के हाल के वर्सनों में, इंटरनेट एक्स्प्लोरर बिना तीसरी पार्टी के नियंत्रण के जावा एपप्लेट्स को समर्थन नहीं कर सकता. सन और दूसरों ने विंडोज के उस और अन्य वर्सनों के लिए मुफ्त जावा रन-टाइम सिस्टम उपलब्ध कराया.
जावा EE रणनीति के लिए प्लेटफॉर्म-स्वतंत्र जावा आवश्यक है और यहां तक कि क्रिर्यान्वयन को प्रमाणित करने के लिए और सख्त वैधीकरण जरुरी है। अंतःस्थापित जावा एनवायरनमेंट का उपयोग करके, यह एनवायरनमेंट वहनीय सर्वर-साइड जैसे वेब सर्विसेस, सर्वलेट्स और इंटरप्राइज जावाबीन्स, साथ ही साथ OSGi पर आधारित अंतःस्थापित सिस्टम को सक्षम बनाता है। ग्लासफिश परियोजना के द्वारा सन जावा EE प्रौद्योगिकी का पूर्ण संचालित, एकीकृत मुक्त स्त्रोत कार्यान्वयन के लिए कार्य कर रहा है।
सन JRE का सुपरसेट भी वितरित करता है जिसे जावा डेवलपमेंट किट, कहा जाता है जिसमे विकास उपकरण जैसे जावा कम्पाइलर, जावाडोक, जार और डीबगर शामिल है।
जावा प्रोग्राम के प्रदर्शन का इसके समतुल्य मूलतः संकलित भाषा में लिखे गए प्रोग्राम से तुलना करना कठिन है क्योंकि जावा के बाईटकोड कम्पाइलर का टारगेट प्लेटफॉर्म, जावा प्लेटफॉर्म ही है और बाईटकोड JVM द्वारा मशीन कोड में या तो भाषांतरित कर दिया जाता है या संकलित कर दिया जाता है। इन दो भिन्न दृष्टिकोणों: स्थैतिक बनाम गतिशील संकलन और पुनः संकलन और अन्य से उत्पन्न परिदृश्यों की तुलना करना बहुत कठिन और अलग है।
संकलित भाषाओं में लिखे प्रोग्रामों की तुलना में जावा में लिखे प्रोग्रामों का धीमा होना और अधिक मेमोरी की आवश्यकता होना एक विशेषता रही है। जो कुछ भी हो, जस्ट-इन टाइम संकलन, के आगमन के कारण जावा प्रोग्रामों की क्रियान्वयन गति तेजी से बढ़ी है, अतिरिक्त भाषा विशेषताएं उत्तम कोड विश्लेषण, और जावा वर्चुअल मशीन में स्वंय इष्टतमीकरण को समर्थन करती है।
ऑब्जेक्ट जीवन चक्र में स्मृति का प्रबंधन करने के लिए जावा एक स्वचालित कचरा संग्रहकर्ता का उपयोग करता है। प्रोग्रामर निर्धारित कर लेता है कब ऑब्जेक्ट का निर्माण होगा और एक बार ऑब्जेक्ट जब और उपयोग के लायक नहीं रह जाता तो उसके स्मृति को पुनः प्राप्त करने की जिम्मेदारी जावा रनटाइम की होती है। एक बार जब ऑब्जेक्ट का कोई सन्दर्भ बाकी नहीं रहता, तब अगम्य ऑब्जेक्ट संग्राहक द्वारा स्वतः मुक्त होने के योग्य हो जाता है। कुछ कुछ मेमोरी रिसाव के समान तब भी जारी रह सकता है अगर एक प्रोग्रामर का कोड किसी ऑब्जेक्ट का एक सन्दर्भ जिसकी अब और जरूरत नहीं है उसे पकड़ता है, उसी तरह जब ओब्जेक्ट्स जिसकी और जरूरत नहीं है वह उस कंटेनर में संग्रहित है जो अभी भी इस्तेमाल में है। अगर अस्तित्वविहीन ऑब्जेक्ट के लिए पद्धतियों को बुलाया जाता हैं, एक "नल पॉइंटर एक्सेप्शन" फेंका जाता है।
जावा के स्वचालित स्मृति प्रबंधन मॉडल के पीछे एक विचार यह है कि प्रोग्रामर्स नियमित स्मृति प्रबंधन को प्रर्दशित करने का बोझ थोड़ा कम कर ले. कुछ भाषाओं में ऑब्जेक्ट के निर्माण के लिए स्मृति स्टेक पर अनुमान से आवंटित की जाती है या स्पष्टतया आवंटित होती है और ढेर से पुनः आवंटित की जाती हैं। हर तरह से स्मृति प्रबंधन की जिम्मेदारी प्रोग्रामर के साथ रहती है। अगर कार्यक्रम किसी ऑब्जेक्ट को पुनःआवंटन नहीं करता है तो एक स्मृति रिसाव उत्पन्न होने लगता है। अगर कार्यक्रम स्मृति का अभिगमन या पुनः आवंटित करने का प्रयास करता है जो पहले ही पुनःआवंटित किया जा चुका है, तब परिणाम का अनुमान लगाना और व्याख्या करना मुश्किल हो जाता है और कार्यक्रम संभवतः या तो अस्थिर और/या तो समाप्त हो जाता हैं। इसे स्मार्ट संकेतों के इस्तेमाल से अंशतः ठीक किया जा सकता है लेकिन यह ऊपरिव्यय और जटिलता को बढाता है।
कचरा संग्रहण किसी भी समय हो सकता है। आदर्शतः यह तब होगा जब कार्यक्रम खाली रहता है। अगर नए ऑब्जेक्ट को आवंटित करने के लिए स्वतंत्र स्मृति अपर्याप्त है तब इसका चलाया जाना निश्चित है, यह क्षणभर के लिए एक कार्यक्रम स्थापित करने का कारण बन सकता है। स्पष्ट स्मृति प्रबंधन जावा में संभव नहीं है।
जावा C/C++ शैली सूचक अंकगणित को समर्थन नहीं करता है, जहां पर ऑब्जेक्ट एड्रेस और अचिन्हित इंटीजर्स को अदला-बदली करके उपयोग किया जा सकता हैं। यह कचरा कलेक्टर को सन्दर्भित ऑब्जेक्टस को स्थानांतरित करने की अनुमति देता है और इसका बचाव और सुरक्षा सुनिश्चित करता है।
जैसा कि C++ और कुछ दूसरे ऑब्जेक्ट-उन्मुख भाषाओँ में, जावा के परिवर्तनीय प्राथमिक प्रकार ऑब्जेक्ट नहीं है। प्राथमिक प्रकारों की उपयोगिता को या तो क्षेत्रों में प्रत्यक्ष रूप से संचित किया जाता है या ढेरों पर ना कि स्टेक पर, जैसा ऑब्जेक्ट के लिए सामान्य तौर पर सही है । जावा के डिजाईनरों द्वारा प्रदर्शन के कारण लिया गया यह एक सजग निर्णय था। इसके कारण, जावा को एक शुद्ध ऑब्जेक्ट-उन्मुख प्रोग्रामिंग भाषा नहीं माना गया। जो कुछ भी हो, जैसा कि जावा 5.0, स्वतः संचालन प्रोग्रामर्स को आगे बढ़ने के लिए सक्षम बनाता है अगर प्राथमिक प्रकारें उनके आवरण श्रेणियों के उदाहरण होते हैं।
जावा के वाक्यविन्यास ज्यादातर C++ से व्युत्पन्न है। C++, जिसमें बनावट, क्रियाविधि और कार्यक्रम वाक्य विन्यास को जोड़ती हैं उससे अलग जावा को केवल एक ऑब्जेक्ट-उन्मुख भाषा के रूप में बनाया गया था। सभी कोड एक क्लास के भीतर लिखे गए हैं और सभी कुछ एक ऑब्जेक्ट है; अंतर्भूत आकड़ों के प्रकारों को छोड़कर, जो प्रदर्शन कारणों से क्लासों नहीं है।
जावा कई विशेषताओं को क्लासों के लिए, छुपाती है ऐसा वह भाषा को सरल बनाने और स्वाभाविक त्रुटियों और अनादर्श रचना को रोकने के लिए करती है।
जावा C++ की तरह ही समीक्षा पद्धति उपयोग करती है। दो विभिन्न प्रकार की समीक्षाएं हैं: एकरेखीय शैली अंकन दो फॉरवर्ड स्लैशेस के साथ और एक बहुरेखीय शैली खुली फॉरवर्ड स्लैश एस्टरिस्क के साथ और बंद एक एस्टरिस्क फॉरवर्ड स्लाश के साथ.
 उदाहरण: 
परम्परानुसार .java प्रत्यय लगाकर उदाहरणस्वरुप HelloWorld.java स्रोत फाइलों का नामकरण पब्लिक क्लास होता है। इसका संकलन HelloWorld.class के नाम से फाइल उपादित करके सबसे पहले जावा कम्पाइलर का इस्तेमाल करके बाईटकोड में होना चाहिए। उसके बाद ही इसे कार्यान्वित या "निष्पादित" किया जा सकता है। जावा स्रोत फाइल में हो सकता है कि सिर्फ एक पब्लिक क्लास हो लेकिन इसमें पब्लिक एक्सेस से तुलना में कम मल्टीपल क्लासों और कितनी भी संख्या में पब्लिक इनर क्लासों शामिल हो सकती है।
एक class जिसे private घोषित किया जा चुका है, उसे किसी भी .java फाइल में संग्रहित किया जा सकता है। कम्पाइलर स्रोत फाइल में परिभाषित हर क्लास के लिए एक क्लास फाइल उत्पन्न करेगा। क्लास फाइल का नाम क्लास का नाम है, .class संलग्नित के साथ. क्लास फाइल पीढी के लिए, नामरहित क्लासों इस तरह प्रबंधित होती हैं जैसे कि उनका नाम उनके संलग्नित क्लास के नाम का संयोजन था, एक $, और एक पूर्णांक.
मुख्य शब्द public सूचित करता है कि एक प्रणाली दूसरे क्लासों में कोड के द्वारा लाया जा सकता है, या क्लास पदानुक्रम के बाहर क्लासों के द्वारा क्लास का प्रयोग हो सकता है। क्लास पदानुक्रम निर्देशिका के नाम से संबंधित होता है जिसमें जावा फाइल रहता है।
एक प्रणाली के आगे का मुख्य शब्द static एक स्थितिक प्रणाली को संकेत करता है जो सिर्फ क्लास से जुड़ा हुआ है, उस क्लास के किसी भी दूसरे विशेष उदाहरण से नहीं। सिर्फ स्थितिक प्रणालियां किसी ऑब्जेक्ट को सन्दर्भ किए बिना आमंत्रित की जा सकती हैं। स्थितिक प्रणालियां किसी भी चर प्रणाली जो स्थैतिक नहीं है उसका अभिगम नहीं कर सकतीं.
मुख्य शब्द void संकेतित करता है कि मुख्य प्रणाली कॉलर को कोई मूल्य वापस नहीं करता. अगर एक जावा प्रोग्राम गलत कोड के साथ बाहर निकलने को है, यह स्पष्टतया जरुर System.exit को बुलाएगा.
प्रणाली नाम "main" जावा भाषा में मुख्य शब्द नहीं है। यह सिर्फ प्रणाली का नाम है जिसे जावा निर्माता कार्यक्रम को नियंत्रण बढ़ाने के लिए बुलाता है। जावा क्लासों जो प्रबंधित परिवेश जैसे एप्प्लेट्स और इंटरप्राइज जावा बीन्स में चलते हैं उसको main प्रणाली की जरुरत नहीं पड़ती हैं या इस्तेमाल नहीं करते. एक जावा कार्यक्रम में बहु क्लासों जिसके पास main प्रणालियां हैं, समाविष्ट हो सकती है, जिसका मतलब हुआ कि VM स्पष्टतया कहने वाला होना चाहिए कि किस क्लास से प्रक्षेपण किया जाए.
मुख्य प्रणाली ]docs/api/java/lang/String.html String] ऑब्जेक्टस की सारणी को जरुर स्वीकार करे. परम्परानुसार, यह args के रूप में सन्दर्भित होता है यद्यपि कोई भी कानूनी पहचान वाला नाम इस्तेमाल किया जा सकता है। जावा 5 के समय से, मुख्य प्रणाली को स्ट्रिंग युक्तियों के स्वेच्छाचारी संख्या के साथ आमंत्रण को अनुमति देते हुए public static void मैं के रूप में, मुख्य प्रणाली परिवर्तित युक्तियों का भी इस्तेमाल कर सकता है। इस वैकल्पिक घोषणा का प्रभाव शब्दार्थतः पहचान योग्य है, लेकिन यह सारणी को बनाने और बढ़ाने के लिए वैकल्पिक वाक्य विन्यास को अनुमति देती है।
जावा निर्माता दिए गए क्लास के भारण द्वारा जावा का प्रक्षेपण करती है और अपने public static void main प्रणाली को शुरू करती है। स्टैंड-अलोन प्रोग्राम्स को स्पष्टतः इस प्रणाली की घोषणा करनी चाहिए। String args मानदंड क्लास को पारित किसी युक्ति सम्मिलित ]docs/api/java/lang/String.html String] ऑब्जेक्ट की सारणी है। main का मापदंड अक्सर नियंत्रण रेखा के माध्यम द्वारा पारित की जाती है।
मुद्रण, जावा मानक लाइब्रेरीज का एक भाग है: ]docs/api/java/lang/System.html System] क्लास एक पब्लिक स्टैटिक क्लास को परिभाषित करता है जिसे बुलाया जाता है ]docs/api/java/lang/System.html#out out] . 'आउट' ऑब्जेक्ट, ]docs/api/java/io/PrintStream.html PrintStream] क्लास का एक उदाहरण है और यह डाटा मुद्रण के लिए कई मानक रहित प्रणालियां प्रदान करता है ]docs/api/java/io/PrintStream.html#println println] जो स्ट्रिंग पारित करने के लिए नई रेखा भी संलग्न करती है।
एक एप्लेट को HTML तत्त्व का इस्तेमाल करके एक HTML दस्तावेज में रखा जाता है। एप्लेट टैग के तीन स्थापित गुण है: code="Hello", JApplet श्रेणी के नाम की विशेषता बताता है और width="200" height="200" एप्लेट के पीक्सेल की चौड़ाई और ऊंचाई को स्थापित करता है। एप्लेट्स को objects या embed अवयव का इस्तेमाल करते हुए HTML में भी अंतःस्थापित किया जा सकता हैं यद्यपि वेब ब्राउज़र द्वारा इन अवयवों के लिए समर्थन असंगत हैं। जो कुछ भी हो, applet टैग को अनुमति दी गयी, इसलिए object टैग जहां भी संबंधित होता है उसे प्राथमिकता मिलती है।
होस्ट ऍप्लिकेशन, विशेष रूप से वेब ब्राउजर, Hello एप्लेट को दृष्टांत देती है और एप्लेट के लिए एक ]docs/api/java/applet/AppletContext.html AppletContext] का निर्माण करती है। एक बार जब एप्लेट खुद ही प्रारंभ हो जाता है, तो इसे AWT प्रदर्शन प्रदानुक्रम में जोड़ दिया जाता है। paint प्रणाली को जब भी प्रदर्शन को खुद खींचने के लिए एप्लेट की जरुरत होती है तो इसे AWT घटना प्रेषण सूत्र द्वारा बुलाई जाती है।
सेवा अनुरोध निवारक को संकेत प्रदान करने के लिए, Hello क्लास, Servlet अंतरफलक द्वारा परिभाषित की गयी service प्रणाली का विरोध करती है। service प्रणाली को एक ServletRequest ऑब्जेक्ट पारित किया जाता है जिसमें ग्राहक के लिए अनुरोध और ServletResponse ग्राहक को वापस की गयी प्रतिक्रिया उत्पन्न करने के लिए उपयोगित ऑब्जेक्ट शामिल हैं। service प्रणाली यह घोषणा करता है कि यह अपवादों ServletException और ]docs/api/java/io/IOException.html IOException] को throws करती है अगर कोई समस्या इसे अनुरोध को प्रतिक्रिया देने से रोकती है।
प्रतिक्रिया ऑब्जेक्ट में setContentType प्रणाली को "text/html" को वापस किए गए डाटा के MIME अवयव प्रकार स्थापित करने के लिए बुलाया जाता है। getWriter प्रणाली प्रतिक्रिया स्वरूप एक ]docs/api/java/io/PrintWriter.html PrintWriter] ऑब्जेक्ट वापस करती है जो डाटा लिखने में उपयोग होती है जो ग्राहक को भेजा गया है। ]docs/api/java/io/PrintWriter.html#println println] प्रणाली को बुलाया जाता है "Hello, world!" स्ट्रिंग लिखने के लिए, प्रतिक्रिया पर और उसके बाद मुद्रक लेखक को बंद करने के लिए ]docs/api/java/io/PrintWriter.html#close close] प्रणाली को बुलाया जाता है, जिस कारण डाटा पर प्रभाव पड़ता है जो ग्राहक को वापस किये जाने वाले स्ट्रीम को लिखा जा चुका है।
जावा सर्वर पेजेस सर्वर साइड जावा EE घटक हैं जो प्रतिक्रियाएं, आमतौर पर HTML पेजेस, ग्राहकों से HTTP अनुरोध उत्पन्न करती हैं। JSPs विशेष परिसीमक के इस्तेमाल द्वारा जावा कोड को एक HTML पेज में अन्तःस्थापित कर लेता है। एक JSP जावा सर्वलेट से संकलित होती है, जावा अनुप्रयोग अपने खुद के अधिकार में, पहली बार अभिगमित हुआ। इसके बाद उत्पत्तित सर्वलेट प्रतिक्रिया उत्पन्न करती हैं।
घुमाव जावा SE प्लेटफॉर्म के लिए ग्राफिकल उपयोगकर्ता अंतरफलक लाइब्रेरी है। अलग दिख रहे दृश्य को पहचानना संभव है और प्लगएबल लुक के द्वारा महसूस कीजिये और घुमाव की प्रणाली को महसूस कीजिये. Windows, GTK और Motif के क्लोन की आपूर्ति सन द्वारा की जाती हैं। एपल भी एक्वा लुक प्रदान करती हैं और Mac OS X के लिए परख, जहां इन लुकों और फील्स के लिए कार्यान्वयन में कमी दिख रही है, जावा SE 6 में घुमाव ज्यादा आंतरिक का देशी विजेट ड्राविंग रूटीन्स का प्रयोग करके इन समस्याओं की तरफ संकेत करता है।
यह उदाहरण घुमाव अनुप्रयोग "Hello, world!" के साथ एक सिंगल विंडो का निर्माण करती हैं अन्दर:
पहला import स्टेटमेंट जावा संग्राहक को ]docs/api/java/awt/package-summary.html java.awt] पैकेज से ]docs/api/java/awt/BorderLayout.html BorderLayout] क्लास संग्राहकता में शामिल करने का निर्देश देती हैं; दूसरा import में सभी सार्वजनिक क्लासों और ]docs/api/javax/swing/package-summary.html javax.swing] पैकेज से अंतरफल सम्मिलत हैं।
Hello निर्माता सबसे पहले सुपर क्लास निर्माता को बुलाकर ढांचे को प्रारंभ करती है, मानदण्ड 'hello' को पारित करते हुए, जिसका विन्डो के शीर्षक के रूप में इस्तेमाल होता हैं। इसके बाद यह jframe से वंशागत ]docs/api/javax/swing/JFrame.html#setDefaultCloseOperation setDefaultCloseOperation] प्रणाली को बुलाती हैं अनुपस्थित ऑपरेशन स्थापित करने के लिए, जब टाइटल बार पर क्लोस कंट्रोल के लिए ]docs/api/javax/swing/WindowConstants.html#EXIT_ON_CLOSE WindowConstants.EXIT_ON_CLOSE] चुना जाता है; यह jframe के नष्ट होने का कारण होती है, जब ढांचा को बंद कर दिया जाता हैं, जो JVM को बाहर जाने की और कार्यक्रम को बाहर निकालने की अनुमति देती हैं। उसके बाद, फ्रेम का ले-आउट Borderlayout पर स्थापित किया जाता है, यह घुमाव को बताता हैं कि अवयवों का कैसे प्रबंध किया जाए जिसे ढांचा में जोड़ा जाये. एक स्ट्रिंग "Hello, world!" के लिए ]docs/api/javax/swing/JLabel.html JLabel] बनाया गया है और ]docs/api/java/awt/Container.html Container] सुपर क्लास पाई गयी ]docs/api/java/awt/Container.html#add add] प्रणाली को ढांचा पर लेबल जोड़ने के लिए बुलाया जाता है। ]docs/api/java/awt/Window.html Window] सुपरक्लास से लिए ]docs/api/java/awt/Window.html#pack pack] प्रणाली को विन्डो को BorderLayout द्वारा संकेतित तरीके में इसके अवयवों के ले आउट को आकार देने के लिए बुलाया जाता हैं।
जब कार्यक्रम शुरू होता हैं main प्रणाली को JVM द्वारा बुलाया जाता है। यह नए Hello ढांचा को दृष्टांत देती हैं और ]docs/api/java/awt/Component.html Component] सुपरक्लास से निकाले हुए ]docs/api/java/awt/Component.html#setVisible setVisible] प्रणाली बुलाकर बुलियन पैरामीटर true के साथ प्रदर्शन का कारण बनती हैं। एक बार जब ढांचा प्रर्दशित हो जाता है, main प्रणाली कार्यक्रम को नुक़सान न पहुंचाए छोड़कर; AWT घटना प्रेषण थ्रेड क्रियाशील बनी रहती हैं और जब तक सभी उच्च स्तरीय विंडो निकल न चुके हो।
2004 में जेनेरिक्स को जावा भाषा में J2SE 5.0 के भाग के रूप में सम्मिलित किया गया। जेनेरिक्स के परिचय की प्राथमिकता, हर परिवर्तनशील घोषणा विशेष प्रकार की होनी चाहिए। कंटेनर क्लासों के लिए उदाहरण के स्वरूप, यह एक समस्या है क्योंकि कंटेनर के निर्माण का कोई सरल रास्ता नहीं है जो सिर्फ विशेष प्रकार की वस्तुओं को स्वीकार करता है। या तो कंटेनर क्लास अथवा अंतरफलक, सामान्यतया object के उपप्रकारों पर संचालन करता है, या विभिन्न कंटेनर क्लास हर कंटेंड क्लास के लिए निर्मित होता है। जेनेरिक्स बड़ी संख्या में कंटेनर क्लासों का निर्माण किए बगैर संकलन-समय प्रकार जांच की अनुमति देती है, प्रत्येक में लगभग समान संकेत होते हैं।
जावाडोक एक व्यापक दस्तावेज़ीकरण सिस्टम है, जिसे सन माइक्रोसिस्टम्स द्वारा बनाया गया और कई जावा डेवलपर्स द्वारा प्रयोग किया गया। यह डेवलपर्स को अपने कोड के दस्तावेज़ीकरण के लिए संगठित व्यवस्था प्रदान करती है। जहां भी जावा और C में साधारण कमेंट्स /* और */, के साथ समाप्त होती हैं, बहुरेखीय कमेन्ट टैग्स, जावाडोक कमेंट्स के शुरुआत में एक अतिरिक्त तारक चिन्ह रहता है, इस तरह टैग्स /** और */ होते हैं।
साँचा:Java platforms
सन ने विभिन्न अप्लिकेशन एनवायरनमेंट को लक्ष्य करते हुए जावा के चार संस्करणों को परिभाषित और समर्थन किया है और अपने APIs को खंडित किया है जिससे कि वे एक प्लेटफॉर्म से सम्बन्धित हो सके। प्लेटफॉर्म निम्नलिखित हैं:
जावा APIs में क्लासों को पृथक समूह में संगठित किया गया हैं जिन्हें पैकेज बुलाया जाते हैं। हर पॅकेज में संबंधित अंतरफलक, क्लासों, एक्स्सेप्शन के सेट सम्मिलित होते हैं। उपलब्ध पैकेजों के विवरण के लिए अलग-अलग प्लेटफार्मों का विवरण सन्दर्भित करे.
सन ने पर्सनलजावा नाम का संस्करण भी प्रदान किया, जो बाद वाले मानकता-आधारित जावा ME विन्यास-प्रोफ़ाइल पैरिंग्स द्वारा प्रदान किया गया।
ओपनसोर्स सॉफ्टवेयरों के विकास के लिये जावा का बहुतायत में प्रयोग होता है। इसके कुछ कारण इसका मुफ्त होना, क्रॉस प्रलेटफार्म होना, यूनिकोड सक्षम होना आदि हैं।
जावा इण्डिक यूनिकोड का पूर्ण समर्थन करती है, इसलिये भारतीय भाषाओं हेतु सॉफ्टवेयर विकास हेतु अत्यन्त उपयोगी है।
साँचा:Java साँचा:Sun Microsystems

